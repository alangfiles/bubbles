// Generated by CoffeeScript 1.3.3
(function() {
  var draw, runtime, update;

  runtime = function(time) {
    window.requestAnimationFrame(runtime, gc);
    update();
    return draw();
  };

  update = function() {
    var active_enemies, bullet, bullets, enemies, enemy, explosions, new_enemy_size, _fn, _fn1, _i, _j, _k, _len, _len1, _len2;
    _fn = function(enemy) {
      var enemy2, _j, _len1, _results;
      _results = [];
      for (_j = 0, _len1 = enemies.length; _j < _len1; _j++) {
        enemy2 = enemies[_j];
        if ((enemy2 !== enemy) && circleCollides(enemy, enemy2) && (enemy2.active && enemy.active)) {
          _results.push((function(enemy) {
            return enemy.join(enemy2);
          })(enemy));
        }
      }
      return _results;
    };
    for (_i = 0, _len = enemies.length; _i < _len; _i++) {
      enemy = enemies[_i];
      _fn(enemy);
    }
    for (_j = 0, _len1 = enemies.length; _j < _len1; _j++) {
      enemy = enemies[_j];
      if (circleCollides(enemy, player1)) {
        (function(enemy) {
          return player1.join(enemy);
        })(enemy);
      }
    }
    _fn1 = function(bullet) {
      var _l, _len3, _results;
      _results = [];
      for (_l = 0, _len3 = enemies.length; _l < _len3; _l++) {
        enemy = enemies[_l];
        if (circleCollides(bullet, enemy)) {
          _results.push((enemy.explode(), bullet.active = false));
        }
      }
      return _results;
    };
    for (_k = 0, _len2 = bullets.length; _k < _len2; _k++) {
      bullet = bullets[_k];
      _fn1(bullet);
    }
    active_enemies = (function() {
      var _l, _len3, _results;
      _results = [];
      for (_l = 0, _len3 = enemies.length; _l < _len3; _l++) {
        enemy = enemies[_l];
        if (enemy.active) {
          _results.push((enemy.update(), enemy));
        }
      }
      return _results;
    })();
    enemies = null;
    enemies = active_enemies;
    explosions = (function() {
      var explosion, _l, _len3, _results;
      _results = [];
      for (_l = 0, _len3 = explosions.length; _l < _len3; _l++) {
        explosion = explosions[_l];
        if (explosion.active) {
          _results.push((explosion.update(), explosion));
        }
      }
      return _results;
    })();
    bullets = (function() {
      var _l, _len3, _results;
      _results = [];
      for (_l = 0, _len3 = bullets.length; _l < _len3; _l++) {
        bullet = bullets[_l];
        if (bullet.active) {
          _results.push((bullet.update(), bullet));
        }
      }
      return _results;
    })();
    player1.update();
    if (enemies.length < MAX_NUMBER_ENEMIES) {
      new_enemy_size = Math.floor(MIN_NEW_ENEMY_SIZE + Math.random() * maxEnemySize(player1));
      if (Math.random() < NEW_ENEMY_PROPABILITY) {
        enemies.push(new Enemy(new_enemy_size));
      }
    }
    if (player1.active === false) {
      start();
    }
    if (player1.radius * 1.2 > CANVAS_HEIGHT) {
      start();
    }
  };

  draw = function() {
    var bullet, enemy, explosion, _i, _j, _k, _len, _len1, _len2, _results;
    gcc.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    player1.draw();
    for (_i = 0, _len = bullets.length; _i < _len; _i++) {
      bullet = bullets[_i];
      bullet.draw();
    }
    for (_j = 0, _len1 = enemies.length; _j < _len1; _j++) {
      enemy = enemies[_j];
      enemy.draw();
    }
    _results = [];
    for (_k = 0, _len2 = explosions.length; _k < _len2; _k++) {
      explosion = explosions[_k];
      _results.push(explosion.draw());
    }
    return _results;
  };

}).call(this);
