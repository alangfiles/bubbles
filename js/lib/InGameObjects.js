// Generated by CoffeeScript 1.3.3
(function() {
  var CircleMovingInGameObject, InGameObject, MovingInGameObject, RectangleMovingInGameObject,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  InGameObject = (function() {

    function InGameObject(active, fill_style, stroke_style, line_width) {
      this.active = active != null ? active : true;
      this.fill_style = fill_style != null ? fill_style : DEFAULT_FILL_STYLE;
      this.stroke_style = stroke_style != null ? stroke_style : DEFAULT_STROKE_STYLE;
      this.line_width = line_width != null ? line_width : DEFAULT_LINE_WIDTH;
      gcc.fillStyle = this.fills_style;
      gcc.strokeStyle = this.stroke_style;
      gcc.lineWidth = this.line_width;
    }

    return InGameObject;

  })();

  MovingInGameObject = (function(_super) {

    __extends(MovingInGameObject, _super);

    function MovingInGameObject(x, y, x_velocity, y_velocity, fill_style, stroke_style, line_width, active) {
      this.x = x;
      this.y = y;
      this.x_velocity = x_velocity != null ? x_velocity : 0;
      this.y_velocity = y_velocity != null ? y_velocity : 0;
      MovingInGameObject.__super__.constructor.call(this, active, fill_style, stroke_style, line_width);
    }

    MovingInGameObject.prototype.update = function() {
      this.x += this.x_velocity;
      return this.y += this.y_velocity;
    };

    return MovingInGameObject;

  })(InGameObject);

  RectangleMovingInGameObject = (function(_super) {

    __extends(RectangleMovingInGameObject, _super);

    function RectangleMovingInGameObject(x, y, width, height, x_velocity, y_velocity, fill_style, stroke_style, line_width, active) {
      this.width = width;
      this.height = height;
      RectangleMovingInGameObject.__super__.constructor.call(this, x, y, x_velocity, y_velocity, fill_style, stroke_style, line_width, active);
    }

    RectangleMovingInGameObject.prototype.inBounds = function() {
      return this.x >= 0 && this.x <= CANVAS_WIDTH && this.y >= 0 && this.y <= CANVAS_HEIGHT;
    };

    RectangleMovingInGameObject.prototype.getF = function() {
      return this.radius * this.radius * Math.PI;
    };

    RectangleMovingInGameObject.prototype.setF = function(newF) {
      return this.radius = Math.sqrt(newF / Math.PI);
    };

    RectangleMovingInGameObject.prototype.addF = function(plusF) {
      return this.setF(this.getF() + plusF);
    };

    RectangleMovingInGameObject.prototype.update = function() {
      RectangleMovingInGameObject.__super__.update.call(this);
      return this.testViability();
    };

    RectangleMovingInGameObject.prototype.testViability = function() {
      return this.active = this.active && inBounds();
    };

    RectangleMovingInGameObject.prototype.draw = function(fill, stroke) {
      if (fill == null) {
        fill = true;
      }
      if (stroke == null) {
        stroke = false;
      }
      if (fill) {
        gcc.fillStyle = this.fill_style;
        gcc.fillRect(this.x, this.y, this.width, this.height);
      }
      if (stroke) {
        gcc.strokeStyle = this.stroke_style;
        return gcc.strokeRect(this.x, this.y, this.width, this.height);
      }
    };

    return RectangleMovingInGameObject;

  })(MovingInGameObject);

  CircleMovingInGameObject = (function(_super) {

    __extends(CircleMovingInGameObject, _super);

    function CircleMovingInGameObject(cx, cy, radius, x_velocity, y_velocity, fill_style, stroke_style, active) {
      this.cx = cx;
      this.cy = cy;
      this.radius = radius;
      this.setCircleBox();
      CircleMovingInGameObject.__super__.constructor.call(this, this.x, this.y, this.width, this.height, x_velocity, y_velocity, fill_style, stroke_style, active);
    }

    CircleMovingInGameObject.prototype.setCircleBox = function() {
      this.width = this.height = this.radius * 2;
      this.x = this.cx - this.radius;
      return this.y = this.cy - this.radius;
    };

    CircleMovingInGameObject.prototype.update = function() {
      this.cx += this.x_velocity;
      this.cy += this.y_velocity;
      this.setCircleBox();
      if (this.inBounds() === false) {
        if (this.cx < 0) {
          this.cx = CANVAS_WIDTH + (this.cx * -1);
        } else if (this.cx > CANVAS_WIDTH) {
          this.cx = (this.cx - CANVAS_WIDTH) * -1;
        }
        if (this.cy < 0) {
          this.cy = CANVAS_HEIGHT + (this.cy * -1);
        } else if (this.cy > CANVAS_HEIGHT) {
          this.cy = (this.cy - CANVAS_HEIGHT) * -1;
        }
      }
      CircleMovingInGameObject.__super__.update.call(this);
      return this.testViability();
    };

    CircleMovingInGameObject.prototype.testViability = function() {
      return this.active = this.active && this.radius > MINIMAL_VIABLE_RADIUS;
    };

    CircleMovingInGameObject.prototype.draw = function() {
      var r, x, y;
      x = (0.5 + this.cx) | 0;
      y = (0.5 + this.cy) | 0;
      r = (0.5 + this.radius) | 0;
      gcc.fillStyle = this.fill_style.toString();
      gcc.strokeStyle = this.stroke_style;
      return gcc.drawCircle((0.5 + this.cx) | 0, (0.5 + this.cy) | 0, (0.5 + this.radius) | 0);
    };

    CircleMovingInGameObject.prototype.inBounds = function() {
      return this.cx > (this.radius * -1) && this.cx < (CANVAS_WIDTH + this.radius) && this.cy > (this.radius * -1) && this.cy < (CANVAS_HEIGHT + this.radius);
    };

    CircleMovingInGameObject.prototype.join = function(another_circle) {
      var looser, newLooserF, oldLooserF, winner;
      if (!this.active) {
        return false;
      }
      if (!another_circle.active) {
        return false;
      }
      if (this.radius < MINIMAL_VIABLE_RADIUS) {
        return false;
      }
      if (another_circle.radius < MINIMAL_VIABLE_RADIUS) {
        return false;
      }
      winner = false;
      looser = false;
      if (this.radius > another_circle.radius) {
        winner = this;
        looser = another_circle;
      } else if (this.radius < another_circle.radius) {
        winner = another_circle;
        looser = this;
      } else {
        if (Math.random() > 0.5) {
          this.explode();
        } else {
          another_circle.explode();
        }
      }
      if (winner && looser) {
        oldLooserF = looser.getF();
        looser.radius = looser.radius - DEFAULT_NEGATIVE_CIRCLE_JOIN_RATE;
        newLooserF = looser.getF();
        winner.addF(oldLooserF - newLooserF);
      }
      return this.testViability();
    };

    CircleMovingInGameObject.prototype.explode = function() {
      this.active = false;
      return explosions.push(new Explosion(this));
    };

    return CircleMovingInGameObject;

  })(RectangleMovingInGameObject);

}).call(this);
